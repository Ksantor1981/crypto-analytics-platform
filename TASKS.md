# Список задач к реализации проекта Crypto Analytics Platform

## Блок 1: Доработка ТЗ и Планирования (1-2 дня)

- [ ] 1.1. Добавить в ТЗ раздел "Ключевые определения":
  - [ ] 1.1.1. Сформулировать определение "Успешный сигнал" (например: "Сигнал, который достиг TP1 и не коснулся SL в течение 24 часов после публикации")
  - [ ] 1.1.2. Сформулировать определение "Точность канала" (например: "Количество успешных сигналов / Общее количество сигналов * 100%")
  - [ ] 1.1.3. Сформулировать определение "ROI сигнала" (например: "((Цена TP1 - Цена входа) / Цена входа) * 100%")
  - [ ] 1.1.4. Сформулировать определение "Максимальная просадка"
  - [ ] 1.1.5. Определить временные рамки для анализа сигналов (24ч, 48ч, 7 дней)

- [ ] 1.2. Уточнить приоритеты функциональности для MVP:
  - [ ] 1.2.1. Определить минимальный набор функций для первого релиза
  - [ ] 1.2.2. Выделить OCR-функциональность в отдельную фазу (не включать в MVP)
  - [ ] 1.2.3. Определить список поддерживаемых криптовалютных пар для MVP

- [ ] 1.3. Создать словарь терминов проекта:
  - [ ] 1.3.1. Определить все специфические термины, используемые в проекте
  - [ ] 1.3.2. Согласовать терминологию с заказчиком/продакт-менеджером

## Блок 2: Разработка ядра системы (Backend)

- [ ] 2.1. Разработка моделей данных:
  - [ ] 2.1.1. Создать директорию backend/app/models/ (если еще не создана)
  - [ ] 2.1.2. Реализовать модель User (пользователи системы)
  - [ ] 2.1.3. Реализовать модель Channel (каналы с сигналами)
  - [ ] 2.1.4. Реализовать модель Signal (сигналы из каналов)
  - [ ] 2.1.5. Реализовать модель Subscription (подписки пользователей)
  - [ ] 2.1.6. Реализовать модель APIKey (API-ключи пользователей)
  - [ ] 2.1.7. Реализовать модель Payment (история платежей) - для соответствия требованиям законодательства и удобства пользователей
  - [ ] 2.1.8. Реализовать модель PerformanceMetric (рассчитанные метрики каналов) - для ускорения загрузки дашбордов

- [ ] 2.2. Настройка миграций базы данных:
  - [ ] 2.2.1. Настроить Alembic для миграций
  - [ ] 2.2.2. Создать первую миграцию для создания таблиц (alembic revision --autogenerate -m "Create initial tables")
  - [ ] 2.2.3. Написать скрипт для заполнения базы тестовыми данными

- [ ] 2.3. Разработка API эндпоинтов:
  - [ ] 2.3.1. Создать директорию backend/app/api/ (если еще не создана)
  - [ ] 2.3.2. Реализовать роутер auth.py для аутентификации (регистрация, логин, JWT)
  - [ ] 2.3.3. Реализовать роутер channels.py для работы с каналами
  - [ ] 2.3.4. Реализовать роутер signals.py для работы с сигналами
  - [ ] 2.3.5. Реализовать роутер users.py для управления профилем
  - [ ] 2.3.6. Реализовать роутер subscriptions.py для интеграции с платежной системой Stripe
  - [ ] 2.3.7. Реализовать роутер api_keys.py для управления API-ключами с учетом интеграции со Stripe
  - [ ] 2.3.8. Реализовать Webhook-эндпоинт для Stripe (/api/webhooks/stripe) - для обработки событий оплаты, отмены подписки и т.д.

- [ ] 2.4. Разработка воркеров для сбора данных:
  - [ ] 2.4.1. Создать директорию workers/telegram/ для Telegram-коллектора
  - [ ] 2.4.2. Адаптировать код парсинга Telegram из старого проекта
  - [ ] 2.4.3. Реализовать логику сохранения сигналов в новую БД
  - [ ] 2.4.4. Настроить периодический запуск через Celery
  - [ ] 2.4.5. Реализовать логирование процесса сбора данных
  - [ ] 2.4.6. Реализовать воркер для проверки исполнения сигналов - для определения достижения TP, SL или истечения времени жизни сигнала

- [ ] 2.5. Разработка ML-сервиса:
  - [ ] 2.5.1. Создать базовую структуру ML-сервиса
  - [ ] 2.5.2. Реализовать API для получения предсказаний
  - [ ] 2.5.3. Реализовать заглушку модели для MVP (без обучения)
  - [ ] 2.5.4. Настроить интеграцию с основным бэкендом

- [ ] 2.6. Настройка системы аутентификации:
  - [ ] 2.6.1. Реализовать JWT-аутентификацию
  - [ ] 2.6.2. Настроить middleware для проверки прав доступа
  - [ ] 2.6.3. Реализовать систему ролей (admin, user, etc.)
  - [ ] 2.6.4. Реализовать логику обновления JWT-токенов (Refresh Token) - для бесшовной аутентификации пользователей

- [ ] 2.7. Разработка тестов:
  - [ ] 2.7.1. Создать директорию backend/tests/
  - [ ] 2.7.2. Написать unit-тесты для моделей
  - [ ] 2.7.3. Написать unit-тесты для API эндпоинтов
  - [ ] 2.7.4. Написать интеграционные тесты для воркеров
  - [ ] 2.7.5. Настроить CI для автоматического запуска тестов

## Блок 3: Разработка Frontend

- [ ] 3.1. Настройка базовой структуры Next.js:
  - [ ] 3.1.1. Настроить структуру директорий (pages, components, hooks, etc.)
  - [ ] 3.1.2. Настроить Tailwind CSS
  - [ ] 3.1.3. Настроить TypeScript

- [ ] 3.2. Разработка компонентов:
  - [ ] 3.2.1. Создать базовые UI компоненты (кнопки, формы, таблицы)
  - [ ] 3.2.2. Создать компоненты для аутентификации (регистрация, логин)
  - [ ] 3.2.3. Создать компоненты для отображения каналов и сигналов
  - [ ] 3.2.4. Создать компоненты для отображения статистики

- [ ] 3.3. Разработка страниц:
  - [ ] 3.3.1. Создать главную страницу (лендинг)
  - [ ] 3.3.2. Создать страницу авторизации
  - [ ] 3.3.3. Создать страницу дашборда
  - [ ] 3.3.4. Создать страницу с рейтингом каналов
  - [ ] 3.3.5. Создать страницу детального просмотра канала
  - [ ] 3.3.6. Создать страницу профиля пользователя
  - [ ] 3.3.7. Создать страницу управления подпиской

- [ ] 3.4. Интеграция с API:
  - [ ] 3.4.1. Настроить HTTP-клиент (axios) и state-менеджер (React Query / SWR)
  - [ ] 3.4.2. Реализовать хуки для работы с API
  - [ ] 3.4.3. Настроить обработку ошибок API
  - [ ] 3.4.4. Реализовать механизм кэширования данных с использованием React Query/SWR

- [ ] 3.5. Разработка тестов для Frontend:
  - [ ] 3.5.1. Настроить Jest для тестирования
  - [ ] 3.5.2. Написать unit-тесты для компонентов
  - [ ] 3.5.3. Написать интеграционные тесты для страниц

## Блок 4: Интеграция и тестирование

- [ ] 4.1. Настройка Docker для разработки:
  - [ ] 4.1.1. Оптимизировать Docker-образы
  - [ ] 4.1.2. Настроить Docker Compose для локальной разработки
  - [ ] 4.1.3. Создать скрипты для удобного запуска

- [ ] 4.2. Интеграционное тестирование:
  - [ ] 4.2.1. Разработать сценарии end-to-end тестирования
  - [ ] 4.2.2. Настроить Cypress для e2e тестов
  - [ ] 4.2.3. Автоматизировать тестирование основных пользовательских сценариев

- [ ] 4.3. Нагрузочное тестирование:
  - [ ] 4.3.1. Разработать сценарии нагрузочного тестирования
  - [ ] 4.3.2. Провести тестирование производительности API
  - [ ] 4.3.3. Оптимизировать узкие места

## Блок 5: Развертывание и поддержка

- [ ] 5.1. Настройка CI/CD:
  - [ ] 5.1.1. Настроить GitHub Actions для автоматической сборки
  - [ ] 5.1.2. Настроить автоматическое развертывание
  - [ ] 5.1.3. Настроить автоматические тесты при пуше
  - [ ] 5.1.4. Настроить линтеры и форматтеры (Black, isort, Prettier) в pre-commit хуках - для обеспечения единого стиля кода

- [ ] 5.2. Мониторинг и логирование:
  - [ ] 5.2.1. Настроить систему мониторинга (Prometheus + Grafana)
  - [ ] 5.2.2. Настроить централизованное логирование
  - [ ] 5.2.3. Настроить алерты при критических ошибках

- [ ] 5.3. Документация:
  - [ ] 5.3.1. Убедиться, что все эндпоинты, модели и параметры корректно описаны в коде для авто-генерации документации API (Swagger/OpenAPI)
  - [ ] 5.3.2. Создать документацию по развертыванию
  - [ ] 5.3.3. Создать руководство пользователя

## Блок 6: Дополнительные функции (после MVP)

- [ ] 6.1. Интеграция с дополнительными источниками:
  - [ ] 6.1.1. Добавить поддержку Reddit
  - [ ] 6.1.2. Добавить поддержку Discord
  - [ ] 6.1.3. Добавить OCR для изображений

- [ ] 6.2. Расширение ML-функциональности:
  - [ ] 6.2.1. Обучить модель на реальных данных
  - [ ] 6.2.2. Добавить анализ настроений (sentiment analysis)
  - [ ] 6.2.3. Реализовать кластеризацию каналов по качеству

- [ ] 6.3. Расширение функциональности платформы:
  - [ ] 6.3.1. Добавить уведомления (email, push)
  - [ ] 6.3.2. Реализовать экспорт данных (CSV, Excel)
  - [ ] 6.3.3. Добавить интеграцию с торговыми ботами

---

**Примечание:** По мере реализации задач, отмечайте их как выполненные, заменяя `[ ]` на `[x]`. Если появляются новые задачи, добавляйте их в конец соответствующего блока или используйте нумерацию с десятичной точкой (например, 2.3.8 или 2.3.7.1). 